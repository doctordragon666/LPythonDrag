### 下载linux的发行版[ubuntu镜像]([下载Ubuntu桌面系统 | Ubuntu](https://cn.ubuntu.com/download/desktop))

来源，官网，或者自己U盘和云盘

下载虚拟机

vm，输入破解码，安装最新的即可

### 升级你的安装工具

```shell
sudo apt update
```

### 安装ssh服务

```shell
sudo apt-get install ssh
sudo apt-get install openssh-server
sudo vim /etc/ssh/sshd_config
```

### 安装Samba服务器

```shell
#查看是否安装
dpkg -l|grep samba
#安装
sudo apt-get install samba samba-common
#卸载
sudo apt-get autoremove samba
```

更改配置文件

```shell
[Share]
comment=This is samba dir
path=/home/martin/
writable=yes
browseable=yes
```

添加用户

```shell
sudo smbpasswd -a user-name
```

接下来会输入你的密码，然后开启服务器就可以在windows看到ubuntu的文件

```shell
sudo service smbd start
sudo service smbd stop
```

### 下载git

```shell
sudo apt install git
```

基本的配置

```shell
git config --global username "Your Name"
git config --global user.email "youremail@yourdomain.com"
```

### 安装vscode

进入vscode官网，选择安装包，然后下载deb

```shell
sudo dpkg -i 文件名.deb
```

输入Y开始安装，在linux上显示为code

登录自己的账户同步设置

### 安装gcc和g++

```shell
sudo apt install build-essential
sudo apt install gcc
sudo apt install g++
```

将会安装一系列安装包，包括gcc,g++,make

或者选择命令2，直接安装gcc

### 安装新的应用商店(商店不能用)

卸载原有商店，然后安装新商店

```shell
sudo apt autoremove --purge snapd
sudo apt install gnome-software
```

### 切换一个新的源(阿里)

直接打开图形界面，然后打开软件和更新，切换源，然后更新缓存，等待10分钟即可

### vim编译器

```shell
sudo apt install vim
```

也可以在应用商店里面获取

### 谷歌浏览器

```shell
wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb
sudo apt install ./google-chrome-stable_current_amd64.deb
```

### mysql数据库服务器和库安装

```shell
sudo apt-get install libmysqlclient-dev
sudo apt-get install mysql-server
```

### protobuf安装


## shell终端命令

#### 用户切换

##### sudo su

切换到管理员下运行(要输入密码)

##### sudo ./main.exe

以管理员身份运行某命令

##### su user-name

切换到user-name运行

##### man [手册的编号] 命令的名字

查看gcc的手册，实际调用less完成显示

| 目   录             | 内   容                            |
| ------------------- | ---------------------------------- |
| /usr/share/man/man1 | 普通命令和应用程序                 |
| /usr/share/man/man2 | 系统调用                           |
| /usr/share/man/man3 | 库调用，主要是libc()函数的使用文档 |
| /usr/share/man/man4 | 设备驱动和网络协议                 |
| /usr/share/man/man5 | 文件的详细格式信息                 |
| /usr/share/man/man6 | 游戏                               |
| /usr/share/man/man7 | 文档使用说明                       |
| /usr/share/man/man8 | 系统管理命令                       |
| /usr/share/man/man9 | 内核源代码或模块的技术指标         |

#### 文件夹操作

##### ls -[l,a,]

列出当前目录下的文件和子目录

- `l` 文件的各种属性，在Linux下，`vdir`命令相当于ls -l 命令
- `a`显示隐藏文件
- `F`分类显示

##### pwd

显示当前目录

##### cd [path]

进入该文件夹目录

`..` 上一级目录

`/`进入根目录

`~`进入用户主目录(以用户的名字命名的文件夹)

`./file`进入当前文件夹下的file子文件夹

##### mkdir -[p] file #创建文件夹

建立一个文件夹叫file，如果父目录不存在则失败。可以用空格隔开，接上多个file，或者使用通配符。

- `p`父目录不存在则一起创建

#### 文件操作

##### mv -[i,b] source.txt target.txt #移动

将源文件移动到目标文件，如果文件存在则替换。

- `i`提示是否替换
- `b`存在则在文件后面添加~

##### cp -[i,b,r] source.txt target.txt #复制

复制文件到目标文件，如果文件存在则替换。

- `i`提示是否替换
- `b`存在则在文件后面添加~
- `r`将子目录一起复制到另外一个子目录下

##### rm -[i,f,r] file #删除

删除文件和空目录，没有提示。

- `i`删除文件或相应目录，删除时进行提醒
- `f`强制性删除文件或相应目录
- `r` 将子目录及其中的文件一并删除。（慎用！特别时在root 权限下）

##### ln -[i,s] source.txt target.txt 建立文件链接

创建硬链接，ls -i 查看可以看到两个文件的inode 值一致。

- `s` 创建软链接,即别名,如果源文件删除，则软链接(别名)也无法访问。

#### 查找和定位

##### find /usr -[name,] test.txt

在指定范围快速查找

##### grep tes

过滤结果中的tes并且返回，一般是联合使用

#### 文件权限

##### chown -[r,h] [root,user-name]:nogroup test.txt

设置文件的所有者为root下user-name组，组名可以为任意内容(除了和所有者同名)，但是所有者必须为已经存在的用户。

- `R`改变一个目录所有文件的所属权

##### chgrp group test.txt

用于单独设置文件的属组

##### chmod [八进制代码] test.txt

简单快捷高效，需要掌握一些基本知识

| 文件类型 | 所有者 | 组   | 其他人 |
| -------- | ------ | ---- | ------ |
| d        | rwx    | rwx  | rwx    |

***

| 表示的符号 | 内容   |
| ---------- | ------ |
| r          | 读     |
| w          | 写     |
| x          | 执行   |
| d          | 文件夹 |
| -          | 文件   |

r，w，x代表1，-，d代表0

drwxrwxrwx可翻译成0111111111

除去第一位，每三个转化为8进制则0777

| 代表 | 实际                 |
| ---- | -------------------- |
| 0600 | root用户拥有一切权力 |
|      |                      |

#### 查看

##### head -[n] file

阅读头部和尾部，n指定行数，省略则默认10行

##### cat -[n] file

一次性在终端打印所有文件内容，适用于小文件，-n显示行号

##### more file

分页查看文本文件，按空格翻页，Q键退出，回车向下滚动一行

##### less file

有命令行模式，可以鼠标滑动，J K 可以上下翻动，空格上下翻页

#### 进程查看

#####  ps -[e,f,A]

查看进程

- e,A都是显示所有的进程
- f显示程序的关系

## vim命令

#### 插入模式

| 命令 | 操作                       |
| ---- | -------------------------- |
| a    | 在光标后插入               |
| i    | 在光标所在位置插入         |
| o    | 在光标所在位置的下一行插入 |
| Esc  | 进入命令模式               |
| :    | 进入行命令模式             |

#### 命令模式

注意组合命令执行的顺序：w ->q ->!

| 命令        | 操作               |
| ----------- | ------------------ |
| :w          | 保存文件           |
| :w filename | 另存为filename     |
| :q          | 退出Vim            |
| :q!         | 强行退出，放弃保存 |

## gcc命令

| 选   项 | 功   能                                          |
| ------- | ------------------------------------------------ |
| -c      | 只激活预处理、编译和汇编,生成.o 目标代码文件     |
| -S      | 只激活预处理和编译，生成扩展名为.s的汇编代码文件 |
| -E      | 只激活预处理，并将结果输出至标准输出             |
| -g      | 为调试程序(如gdb)生成相关信息                    |
| -O      | 等同-O1,常用的编译优化选项                       |
| -Wall   | 打开一些很有用的警告选项，建议编译时加此选项。   |


# socket概述

分为2种方面

### 客户端

首先是创建一个socket套接字用于网络通信

注意，创建的时候需要指定连接服务器的IP地址

否则系统的自动绑定将会出错

然后用connect函数去连接服务器端

连接成功后调用write和read来读取服务器传回来的数据和向服务器发送内容。

close可以关闭与服务器的连接。

### 服务器端

同客户端，需要创建一个socket；

然后要使用bind来绑定某个端口

然后使用listen函数来监听某个这个端口的信息。阻塞进程。

accept来连接客户端，开启线程。

调用读写函数来与客户端进行交流。

close()函数用来关闭当前连接。

# socket编程基础

### sockaddr数据结构

早期的数据结构

```c
struct sockaddr {
	sa_family_t sa_family; 	/* 协议家族, AF_xxx */
	char sa_data[14];	/* 14 bytes of 协议地址 */
};
```

后来的数据结构

```c
struct sockaddr_in {
     sa_family_t   sin_family; /* 协议家族: AF_INET */
     in_port_t  sin_port;   /* 端口号 */
     struct in_addr sin_addr;   /* 网络地址 */
 };
struct in_addr {
    uint32_t       s_addr;     /* 网络ip地址 byte order */
};
```

#### 常见的协议家族

- `AF_INET `IPV4协议地址
- `AF_INET `IPV6协议地址

#### 常见设置端口号的函数

传入一个数字转化为网络的字节序

```c
#include <arpa/inet.h>
uint16_t htons(uint16_t hostshort);//host to network short
```

#### 常见设置ip地址的函数

传入一个数字转化为网络的字节序

`INADDR_ANY`，一个可以转化为本地地址的变量

```c

#include <arpa/inet.h>
uint32_t htonl(uint32_t hostlong);//host to network long
int inet_pton(int af, const char *src, void *dst);
//参数，第一个协议，第二个是IP的字符串第三个是结果存放的地方
```

### socket函数

```c
#include <sys/types.h>
#include <sys/socket.h>
int socket(int domain, int type, int protocol);
/*
domain:
	AF_INET 这是大多数用来产生socket的协议，使用TCP或UDP来传输，用IPv4的地址
	AF_INET6 与上面类似，不过是来用IPv6的地址
	AF_UNIX 本地协议，使用在Unix和Linux系统上，一般都是当客户端和服务器在同一台及其上的时候使用
type:
	SOCK_STREAM 这个协议是按照顺序的、可靠的、数据完整的基于字节流的连接。这是一个使用最多的socket类型，这个socket是使用TCP来进行传输。
	SOCK_DGRAM 这个协议是无连接的、固定长度的传输调用。该协议是不可靠的，使用UDP来进行它的连接。
	SOCK_SEQPACKET该协议是双线路的、可靠的连接，发送固定长度的数据包进行传输。必须把这个包完整的接受才能进行读取。
	SOCK_RAW socket类型提供单一的网络访问，这个socket类型使用ICMP公共协议。（ping、traceroute使用该协议）
	SOCK_RDM 这个类型是很少使用的，在大部分的操作系统上没有实现，它是提供给数据链路层使用，不保证数据包的顺序
protocol:
	传0 表示使用默认协议。
	*/

```

socket()打开一个网络通讯端口，如果成功的话，

就像open()一样返回一个文件描述符，应用程序

可以像读写文件一样用read/write在网络上收发

数据，如果socket()调用出错则返回-1。

### bind函数

```c
#include <sys/types.h> 
#include <sys/socket.h>
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
/*
sockfd：
	socket文件描述符
addr:
	构造出IP地址加端口号
addrlen:
	sizeof(addr)长度
返回值：
	成功返回0，失败返回-1, 设置errno
*/

```

bind()的作用是将参数sockfd和addr绑定在一起，

使sockfd这个用于网络通讯的文件描述符监听

addr所描述的地址和端口号。

### listen函数

```c
#include <sys/types.h> 
#include <sys/socket.h>
int listen(int sockfd, int backlog);
/*
sockfd:
	socket文件描述符
backlog:
	在Linux 系统中，它是指排队等待建立3次握手队列长度,建议128,最多的连接的人数
*/
```

### accept函数

```c
#include <sys/types.h> 		
#include <sys/socket.h>
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
/*
sockdf:
	socket文件描述符
addr:
	传出参数，返回链接客户端地址信息，含IP地址和端口号
addrlen:
	传入传出参数（值-结果）,传入sizeof(addr)大小，函数返回时返回真正接收到地址结构体的大小
返回值：
	成功返回一个新的socket文件描述符，用于和客户端通信，失败返回-1，设置errno
*/
```

### connect函数

```c
#include <sys/types.h> 		
#include <sys/socket.h>
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
/*
sockdf:
	socket文件描述符
addr:
	传入参数，指定服务器端地址信息，含IP地址和端口号
addrlen:
	传入参数,传入sizeof(addr)大小
返回值：
	成功返回0，失败返回-1，设置errno

*/
```

客户端需要调用connect()连接服务器，connect

和bind的参数形式一致，区别在于bind的参数是

自己的地址，而connect的参数是对方的地址。

connect()成功返回0，出错返回-1。

### send函数

TCP协议用来发送数据的函数

```C
#include <sys/types.h>
#include <sys/socket.h>
ssize_t send(int sockfd, const void *buf, size_t len, int flags);
/*
sockfd参数
1）用于通信的通信描述符
2）对于服务器，就是指accept函数返回的通信描述符
buf参数
1）指向一片应用缓存，用于存放要发送的数据
2）存放数据一般使用结构体变量
len参数
1）存放发送数据的缓存的大小
flags参数
1）一般设置为0，此时是阻塞发送的
2）阻塞发送是指发送数据不成功会一直阻塞，直到被某信号中断或发送成功为止，不过发送数据一般不阻塞
*/
```

# UDP协议

### TCP与UDP

TCP通信，是一个有序的、可靠的、面向连接的。

UDP通信，是不保证有序到达的数据报服务。（在局域网内，使用UDP已很可靠）

### 使用UDP通信与TCP通信使用上的区别

  创建套接字时的type(参数2）不同。

​     TCP通信，使用SOCK_STREAM

​     UDP通信，使用SOCK_DGRAM

  

发送数据和接收数据时，使用的接口不同

​     TCP通信，发送数据，使用write（或send）

​            接收数据，使用read（或recv）

​     UDP特性，发送数据，使用sendto   

​         接收数据，服务器端使用recvfrom 

​               客户端使用recv

​           

不需要使用listen

不需要先建立连接(TCP客户端和服务器端分别使用connect和receive建立连接)

  

###   步骤总结：

   基于UDP的网络套接字通信

####    服务器端

​    (1) 创建一个网络套接字

​    (2) 设置服务器地址

​    (3) 绑定该套接字，使得该套接字和对应的端口关联起来   

​    (4) 循环处理客户端请求

​       使用recvfrom等待接收客户端发送的数据

​       使用sendto发送数据至客户端

####    客户端

​    (1) 创建一个套接字

​    (2) 设置服务器地址

​    (3) 使用sendto向服务器端（接收端）发送数据

​    (4) 使用recv接受数据

  

### sendto与recvfrom、recv

#### 1) sendto

​    功能：UDP服务器或客户端用于发送数据

​    原型：
```c
int sendto (int sockfd,         // 套接字  
            void *buff,      // 发送缓存区
            size_t len,      // 发送缓冲区的长度
            init flags,      // 标志，一般取0
            struct sockaddr *to,  // 目的主机地址
            socklen_t tolen    // 目的主机地址长度
			);
```
返回值：成功，返回实际发送数据的字节数

​				失败，返回-1

​          

####   2) recvfrom

​     功能：UDP服务器用于接收数据

​     原型： 与sendto类似。
```c
int recvfrom (int sockfd,   // 套接字
              void *buff,         // 接收缓存区
              size_t len,         // 接受缓冲区的长度
              init flags,         // 标志，一般取0
              struct sockaddr *to,  // 源主机地址
              socklen_t *tolen     // 源主机地址长度
        );
```
​     注意：参数6必须要初始化为对应地址的长度！

 

####    3) recv

​     功能：UDP客户端用于接收数据

​     原型： ssize_t recv (int sockfd, void *buf, size_t len,  int flags);       

​     注意： 该调用的参数不需要指定地址。最后一个参数取0

  

因为当使用UDP时，对应的套接字被自动绑定在一个短暂的动态的端口上。

### 设置非阻塞IO模型的设置

方式一: 创建socket 时指定

```c
int s = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, IPPROTO_TCP);
```

方式二: 在使用前通过如下方式设定

```c
#include <fcntl.h>

fcntl(sockfd, F_SETFL, fcntl(sockfd, F_GETFL, 0) | O_NONBLOCK);
//man fcntl
//F_SETFL修改文件描述符为第三个参数的值
//F_GETFL会返回特定的值
```

设置后要判断recvfrom的返回值是否为`EWOULDBLOCK|EAGAIN`，如果为否，则可以继续执行其他事情。


# Linux文件操作方式

```c
#include <unistd.h>
```



### 预定义的文件描述符

0. 标准输出，键盘输出
1. 标准输出，控制台打印
2. 标准错误.

### write

> **int len = write(int fd, char *buf, size_t size);**

成功返回实际写入的字节数。

失败返回-1， 错误编号写入errno。

从文件打开的当前指针位置写入

### read

> **int len = read(int fd, char *buf, size_t size);**

\> 0 ：实际读到的字节数

0：已经到文件尾部

-1：出错

程序示例

```c
/*
程序的作用是使用write在终端写入指定内容，然后返回文件大小，调用read读取终端内容
*/
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>

#define filename "write.txt"

int main()
{
	int len = 0;

	char buf[64] = "this is for write now \n";

	len = write(1, buf, strlen(buf));
	if (len >= 0)
	{
		printf("write %d size\n", len);
	}
	else
	{
		printf("write to stdout failed, reason:%s \n", strerror(errno));
	}

	len = read(0, buf, strlen(buf));
	if (len >= 0)
	{
		printf("has already read %d size, read that %s", len, buf);
	}
	else
	{
		printf("read failed to stderr, reason: %s", strerror(errno));
	}

	return 0;
}

/*
在vscode 中输出的结果为：
this is for write now 
write 23 size
this is for read now
has already read 21 size, read that this is for read now
*/
```

***

### open

> **int fd = open(char* filename, int flags, mode_t mode);**

打开文件，并指定读取方式和权限

第三个参数是可选的，当使用了O_CREAT时需要指定

> **S_I (R/W/X) (USR/GRP/OTH)**

可读可写：S_IRUSR|S_IWUSR

可以用8进制表示方法来使用

RWX代表8进制的三位数，然后将第一位置0

如可读可写为0110即6

user属于第一位，所以使用者可读可写为0600

### close

> close(int fd);

关闭文件描述符

```c
/*
写入一个字符串到文件write,txt
*/
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>

#define FILENAME "./write.txt"
#define FILESIZE 1024

int main()
{
	int fd;
	int count;
	char buffer[FILESIZE] = "I am not alone";

	//fd = open(FILENAME, O_CREAT|O_RDWR|O_APPEND|O_TRUNC, S_IRWXU|S_IRGRP|S_IXGRP|S_IROTH);
	fd = open(FILENAME, O_CREAT|O_RDWR|O_APPEND|O_TRUNC, 0600);//0600八进制表示法，表示对所有人可读可写
	if (fd < 0)
	{
		printf("open file martin.txt failed. reason:%s\n", strerror(errno));
		return -1;
	}
	
	count = write(fd, buffer, strlen(buffer));

	printf("written:%d size.\n",count);
	
	close(fd);
	return 0;
}

/*
控制台
written:14 size.
文件：
I am not alone
*/
```

### lseek

> int len = lseek(int fd,  off_t offset, int whence);

成功返回文件位置和文件头的偏移

根据whence来指定结束位置或者设置文件指针在 offset位置。

<!-- more -->

示例:

从文件偏移量100位置拷贝100字节到新文件

```c
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>

#define FILENAME1 "./write.txt"
#define FILENAME2 "./write1.txt"
#define FILESIZE 1024

int main()
{
	int fd1, fd2;
	int count;
	char buffer[FILESIZE];

	fd1 = open(FILENAME1, O_RDONLY); // 0600八进制表示法，表示对所有人可读可写
	if (fd1 < 0)
	{
		printf("open file %s failed. reason:%s\n", FILENAME1, strerror(errno));
		return -1;
	}

	fd2 = open(FILENAME2, O_WRONLY|O_CREAT, 0600);
	if (fd2 < 0)
	{
		printf("open file %s failed. reason:%s\n", FILENAME2, strerror(errno));
		return -1;
	}
	
	count = lseek(fd1, 0 ,SEEK_END);
	printf("file1 has %d count\n", count);

	count = lseek(fd1, 100, SEEK_SET);
	printf("file ret is %d\n", count);

	count = read(fd1,buffer,sizeof(buffer));
	if (count > 0)
	{
		printf("has already write %d size to new_file\n",count);
		buffer[count] = '\0';
		write(fd2, buffer, strlen(buffer));
	}

	close(fd1);
	close(fd2);
	return 0;
}
/*
在vscode中输出的结果为
file1 has 740 count
file ret is 100
has already write 640 size to new_file
*/
```


# http服务器概述

因为客户端已经成为了浏览器，理论上只需要设计服务器即可。分为以下几部分来实现

1.接受http请求

读取请求行(对http请求要有了解)

2.解析请求

GET请求: 获取url，然后返回url里面的文件

其他请求: 返回501界面

格式出错返回bad request

3.响应请求：上面已经提到

额外操作：

读取文件和并发处理

### http头部分析

分为四行，都以`\r\n`结束

##### 客户端

请求行：包括`请求方法`，`url`，`协议版本`

请求头部：字段名`:`值

空行：

请求的数据：

##### 服务器端

状态行：`协议版本`，`响应代号`，`代号描述`

消息报头：字段名`:`值

空行：

响应正文：

##### 常见响应代号

|                                            | 响应代号 | 代号描述               |
| ------------------------------------------ | -------- | ---------------------- |
| 服务器上存在请求的内容，并可以响应给客户端 | 200      | OK                     |
| 客户端的请求有异常，方法有问题             | 501      | Method Not Implemented |
| 服务器收到请求后，因为自生的问题没法响应   | 500      | Internal Server Error  |
| 请求的内容不存在                           | 404      | NOT FOUND              |
| 客户端发送的请求格式有问题等               | 400      | BAD REQUEST            |

### stat函数

```c
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
int stat(const char *path, struct stat *buf);//文件的名字状态
int fstat(int fd, struct stat *buf);//文件句柄获取状态
int lstat(const char* path, struct stat *buf);//不常用
/*
path:
	文件的路径
buf:
	传入的保存文件状态的指针，用于保存文件的状态
返回值：
	成功返回0，失败返回-1，设置errno
*/
struct stat {
               dev_t     st_dev;     /*  文件的设备编号 */
               ino_t     st_ino;     /* inode number */
               mode_t    st_mode;    /* S_ISREG(st_mode)  是一个普通文件  S_ISDIR(st_mode)  是一个目录*/
               nlink_t   st_nlink;   /* 连接到该文件的硬连接数目，刚建立的文件值为1 */
               uid_t     st_uid;     /* 文件所有者的用户识别码 */
               gid_t     st_gid;     /* 文件所有者的组识别码 */
               dev_t     st_rdev;    /* 若此文件为装置设备文件, 则为其设备编号 */
               off_t     st_size;    /* 总大小，单位b */
               blksize_t st_blksize; /* 文件系统的I/O 缓冲区大小. */
               blkcnt_t  st_blocks;  /* 占用文件区块的个数, 每一区块大小为512 个字节 */
               time_t    st_atime;   /* 最后一次访问的时间 */
               time_t    st_mtime;   /* 最后一次修改的时间*/
               time_t    st_ctime;   /* 最近一次被更改的时间 */
           };
```

# 实战

### 处理头部

| 请求方法 | 空格 | URL  | 空格 | 协议版本 | \r\n |
| -------- | ---- | ---- | ---- | -------- | ---- |
| 字段名   | :    | 值   | \r\n |          |      |
| \r\n     |      |      |      |          |      |
| data     |      |      |      |          |      |

先把每一行读取下来

然后分别进行解析

### 解析请求

get请求可以继续读取，并且处理url中的符号

使用snprintf来完成格式化字符串。

对于不存在的文件响应not_found

其他请求则响应badrequest

如果可能，尽量将这些文件放在不同的文件夹中。

### 响应请求

组装好服务器的头部，然后返回客户端一个界面即可。注意过程中要对使用url定位本地文件，使用一个文件夹专门存放html文件，使用拼接来定位文件地址。

| 协议版本 | 空格 | 响应代号 | 空格 | 代号描述 | \r\n |
| -------- | ---- | -------- | ---- | -------- | ---- |
| 字段名   | :    | 值       | \r\n |          |      |
| \r\n     |      |          |      |          |      |
| data     |      |          |      |          |      |

### 开启线程

首先要把请求函数写成线程函数，然后准备线程的相关参数。开启线程，等待其结束。


# Make和CMake

### Make使用

在linux下，有一个命令叫make， 可以实现自动化编译。

```shell
user-name@ubuntu:~/Desktop$ make
user-name@ubuntu:~/Desktop$ make clean
```

就会在目标文件下生成一个可执行文件

第二条语句会清除生成的中间文件

### Makefile的规则

首先只需要在文件目录下写一个文件Makefile或者makefile的文件

```makefile
target: prerequisites ...
	command
```

- target是目标文件，也就是最终的可执行文件
- prerequisites就是生成目标文件需要的原料
- command就是需要生成目标文件的shell命令

**target也可以是一个标签， 例如上面的clean就是一个标签**

查看一个示例

```makefile
target: hello.c
	gcc hello.c -o target
```

### Makefile的工作流程

`make`会在当前目录找到`makefile`的文件

找到，会将第一个`target`作为终极目标文件

如果`target`不存在，就会执行生成命令

如果相关的`hello.o`不存在，则向下查找，最终执行第一条命令，生成目标文件

### Makefile变量

可以将重复的内容提取变量

例如

```makefile
objects = hello.o speak.o
```

然后就可以进行改变

原来的makefile

```makefile
hello_demo : main.o speak.o
        gcc -o hello_demo main.o speak.o

speak.o : speak.c speak.h
        gcc -g -c speak.c

main.o : main.c speak.h
        gcc -g -c main.c

.PHONY: clean # 声明了一个标签，作用，防止将clean看成一个文件，导致循环编译

clean : 
        rm hello_demo main.o speak.o
```

改进后的makefile

```makefile
objects = main.o speak.o
hello_demo : $(objects)
        gcc -o hello_demo $(objects)

speak.o : speak.c speak.h
        gcc -g -c speak.c

main.o : main.c speak.h
        gcc -g -c main.c

.PHONY: clean # 声明了一个标签，作用，防止将clean看成一个文件，导致循环编译

clean : 
        rm hello_demo $(objects)
```

### Makefile自动推导

make会根据hello.o文件，自动的查找hello.c文件，然后执行语句

所以可以再次精简

```makefile
objects = main.o speak.o
hello_demo : $(objects)
        gcc -o hello_demo $(objects)

$(objects): speak.h

.PHONY: clean # 声明了一个伪标签，作用，防止将clean看成一个文件，导致循环编译

clean : 
        rm hello_demo $(objects)
```

### CMake

当项目比较复杂时，makefile的编译会更加复杂，所以使用CMake

安装

```shell
sudo apt-get install cmake
```

编译流程

1. 编写配置文件`CMakeLists.txt`
2. 执行命令，`cmake PATH`,  PATH是文件当前所在目录（一般使用`cmake .`即在当前目录下生成  ）
3. 使用make编译

一些常见的函数

| 函数                   | 参数                                                         | 作用                                       |
| ---------------------- | ------------------------------------------------------------ | ------------------------------------------ |
| cmake_minimum_required | VERION 版本号                                                | 最低版本要求X                              |
| project                | 项目名称                                                     | 生成一个项目                               |
| add_executable         | 第一个为目标，后面接若干个资源文件                           | 生成项目                                   |
| include_directories    | 包含的路径                                                   | 将路径下的文件放在头文件的搜索目录下       |
| link_directories       | 链接的路径                                                   | 将路径下的链接库放在需要链接的库文件目录下 |
| aux_source_directory   | 第一个路径，第二个变量                                       | 将指定路径下的源文件的名字存储到变量中     |
| set                    | 第一个设置的变量， 第二个值                                  | 赋值语句                                   |
| target_link_libraries  | 第一个目标文件，第二个为库文件                               | 将目标文件与库文件进行链接                 |
| add_subdirectory       | 子目录                                                       | 添加子目录                                 |
| install                | 需要接上特定符号**TARGETS**安装目标,**DESTINATION**安装到bin | 配置安装目录                               |

一些常见的变量

1. **PROJECT_SOURCE_DIR**: 项目资源文件夹, CMakeLists.txt所在的目录
2. **CMAKE_CXX_FLAGS**:  编译的参数
3. **PROJECT_NAME**: 项目名称
4. **CMKE_BINARY_DIR**: cmake的bin文件夹

示例:

```cmake
# 流程:版本要求,项目名称,将文件和链接放在头文件的搜索目录下,将目标文件和库文件链接,然后生成项目
#CMake 最低版本要求
cmake_minimum_required(VERSION 2.8)

# 项目信息
project(hellospeak)

# 指定生成的目标
add_executable(Cmake_speak speak.c main.c)
```
# gdb调试

### 安装gdb

```shell
# 源码安装
wget http://ftp.gnu.org/gnu/gdb/gdb-8.1.1.tar.gz
tar -zxvf gdb-8.1.1.tar.gz
cd gdb-8.1.1
./configure
make
make install
#直接自动安装
sudo apt-get install gdb
```

### 启动gdb

在编译的时候添加选项-g(注意单独编译的头文件一样需要添加选项)

```shell
gcc -g hello.c -o hello
gcc -g -c hello.c hello.o
```

相当于windows下的以调试模式运行，生成的文件很大，包含的调试信息

```shell
#指定调试程序
gdb hello
```

使用上述命令进入gdb命令行(同shell，有自动补全和缩写命令)。

### 常见的命令

| 命令                              | 作用                             |
| --------------------------------- | -------------------------------- |
| help(h) [command]                 | 查看帮助，可以跟上参数           |
| break [行号,函数名] if [条件语句] | 设置(条件)断点                   |
| clear [行号，函数名]              | 清除断点                         |
| run(r)                            | 运行调试程序                     |
| next(n) times                     | 单步执行times行                  |
| continue(c)                       | 继续运行直到下一个断点           |
| step(s)                           | 会进入到函数内部                 |
| print [变量名]                    | 监视变量，打印                   |
| watch [变量名]                    | 变量变化时会停止，并且打印变量。 |
| set var [赋值表达式]              | 修改某个变量的值，达到快速调试   |
| backtrace(bt)                     | 打印堆栈信息                     |
| where                             | 也可以打印堆栈信息               |
| quit(q)                           | 退出调试                         |

### 常见的info命令

| info命令 | 解释                                 |
| -------- | ------------------------------------ |
| break    | 查看已经设置的断点                   |
| frame    | 打印出更为详细的当前栈层的信息       |
| args     | 打印出当前函数的参数名及其值。       |
| locals   | 打印出当前函数中所有局部变量及其值。 |

  info frame(f)大多数都是运行时的内存地址。比如：函数地址，调用函数的地址，被调用函数的地址，目前的函数是由什么样的程序语言写成的、函数参数地址及值、局部变量的地址等等。

而frame会打印栈的层编号，当前的函数名，函数参数值，函数所在文件及行号，函数执行到的语句。

# Coredump

### 定义 

程序异常退出时，会产生一个core文件，该文件记录了程序运行时的内存，寄存器状态，堆栈指针，内存管理信息还有各种函数调用堆栈信息等，我们可以理解为是程序工作当前状态存储生成的一个文件，通过工具分析这个文件，我们可以定位到程序异常退出的时候对应的堆栈调用等信息，找出问题所在并进行及时解决。

### 前期设置

1. 设置core文件生成的目录，其中%e表示程序文件名，%p表示进程ID，否则会在程序的当前目录生成dore文件；

   确保/data/coredump/目录要存在，否则会无法coredump

   ```shell
   # 查看当前目录的值
   cat /proc/sys/kernel/core_pattern
   # 转化为当前目录
   echo /data/coredump/core.%e.%p>/proc/sys/kernel/core_pattern #前面的是格式>后面的是固定
   ```

2. 当前执行程序的用户对core目录有写权限且有足够的空间存储core文件，可以将上面的文件设置为0666权限

3. 进入/data目录下，执行如下命令，生成不受限制的core文件；

   ```shell
   ulimit -c unlimited
   ulimit -a #查看所有的属性
   ```

### 如何调试

1)编译的时候添加-g选项，增加调试信息

2) 运行命令

```shell
gdb 出问题的程序 生成的core文件
```

就会快速定位到出问题的语句

  如果你要查看某一层的信息，你需要切换当前的栈，一般来说，程序停止时，最顶层的栈就是当前栈，如果你要查看栈下面层的详细信息，首先要做的是切换当前栈。

### 不常用的命令

| 序号 | 命令                | 作用              |
| ---- | ------------------- | ----------------- |
| 1    | frame(f) \<n\>      | 查看栈的第n层。   |
| 2    | up \<n\>            | 向栈的上面移动n层 |
| 3    | down\<n\>           | 向栈的下面移动n层 |
| 4    | select-frame \<n\>  | 不会打印信息同1   |
| 5    | up-silently \<n\>   | 2                 |
| 6    | down-silently \<n\> | 3                 |

### 打印堆栈

 使用信号来调用函数

```c
/*
信号钩子函数，获取栈信息，然后在日志中打印
*/
#include <execinfo.h>
void handle_segv(int signum)
{
  void *array[100];
  size_t size;
  char **strings;
  size_t i;
    
  signal(signum, SIG_DFL); /* 还原默认的信号处理handler */
  size = backtrace(array, 100);
  strings = (char **)backtrace_symbols (array, size);
  fprintf(stderr,"Launcher received SIG: %d Stack trace:\n", signum);
    
  for (i = 0; i < size; i++)
  {
    fprintf(stderr,"%d %s \n",i,strings[i]);
  }
    
  free (strings);
}

```

在main 函数中加入：
```c
 signal(SIGSEGV, handle_segv); // SIGSEGV 11: Core Invalid memory reference
 signal(SIGABRT, handle_segv); // SIGABRT 6: Core Abort signal from
```


注意：编译时一定要带上 -g 选项 

使用addr2line命令检测:

```shell
addr2line -a [0x4007fa] -e 程序名
```

中间的值是根据handle_segv信号捕捉函数打印出来的数值确定的。

```shell
0 ./demo [0x4007fa]
```


# 谷歌自动测试框架

是一个高效的c++框架

### 安装框架

```shell
git clone https://github.com/google/googletest.git
cd googletest
cmake .
make
sudo make install
```

### 测试文件编写

test宏函数

```c++
TEST(test_case_name, test_name)
```

测试的函数，测试的名字

| Expect/ASSERT     | 作用                                |
| ----------------- | ----------------------------------- |
| TRUE/FALSE        | 逻辑判断                            |
| EQ/NE/LT/GT/LE/GE | =/!=/</>/<=/>=                      |
| STREQ             | 两个C风格的字符串相等才正确返回     |
| STRNE             | 两个C风格的字符串不相等时才正确返回 |
|                   |                                     |

### 使用测试框架

```shell
gcc sample1.cc sample_unittest.cc -lgtest -std=c++11 [-lgtest_main] -lpthread -o test1
./test
```

不带lgtest_main参数则需要自己手写gtest的main函数来进行测试

```c++
#include <limits.h>
#include <gtest/gtest.h>

int main(int argc, char**argv)
{
	testing::InitGoogleTest(&argc, argv);
	return RUN_ALL_TESTS();
}
```


# Valgrind和Memcheck

### 安装

Memcheck是Valgrind的一个小工具，首先要下载Valgrind。

```shell
sudo apt-get install valgrind
```

### 检测的范围

1. 对未初始化内存的使用； 

2. 读/写释放后的内存块；

3. 读/写超出malloc等分配的动态内存范围； 

4. 读/写不适当的栈中内存块； 

5. 内存泄漏，指向一块内存的指针永远丢失； 

6. 不正确的malloc/free或new/delete匹配； 

7. memcpy()相关函数中的dst和src指针重叠问题。 

###  检查的步骤和注意事项

```shell
valgrind --tool=memcheck --leak-check=full --log-file=./log.txt  ./YourProgram
```

### 结果分析

```

```

# [iniparser](https://github.com/ndevilla/iniparser)的配置

### 配置文件的准备

准备文件shard_bike_ini，编写如下内容

```ini
[database]
ip       = 127.0.0.1 ;
port     = 3306 ;
user     = root ;
pwd      = 123456 ;
db       = qiniubike;

[server]
port     = 9090;
```

文件内容的准备

```shell
mkdir project
mkdir conf # 还有git,src(源代码),test, third,include
cd git & git clone https://github.com/ndevilla/iniparser
#下载后会生成目录，进入
cd src# 拿到iniparser.c和iniparser.h和dictionary.h，然后回到git,放入include
make
#make install # 不支持install
#libiniparser.a和libiniparser.so.l这两个链接库可以放入third

# 查看example
```

### 代码部分

main.cpp

```c
#include "iniconfig.h"
#include "configdef.h"

int main(int argc, char**argv)
{
    if (argc != 2)
    {
        printf("Please input shbk <config file path>!\n");
        return -1;
    }
    
    Iniconfig config;
    if (!config.loadfile(std::string(argv[1])))
    {
        printf("load %s faile.\n", argv[1]);
        return -2;
    }

    st_env_config conf_args = config.getconfig();
    printf("[database] ip:%s port:%d user:%s pwd:%s db:%s [server] port:%d\n",
    conf_args.db_ip.c_str(),conf_args.db_port, conf_args.db_user.c_str(), conf_args.db_pwd.c_str()
    ,conf_args.db_name.c_str(), conf_args.svr_port);
    
    return 0;
}
```

### ini配置头文件和实现

**头文件**

> 属性
>
> 1. 是否加载==防止重复构造
> 2. 定义一个全局属性
>
> 方法：
>
> 1. 构造和析构
> 2. 通过文件路径加载文件
> 3. 获取属性

```c++
#ifndef SHBK_COMMON_INTCONFIG_H_
#define SHBK_COMMON_INTCONFIG_H_

#include "configdef.h"

class Iniconfig
{
protected:
    Iniconfig();
private:
    bool _isloaded;
    st_env_config _config;
    static Iniconfig* config;
public:
    ~Iniconfig();
    static Iniconfig* getInstance();
    bool loadfile(const std::string& path);
    const st_env_config& getconfig();
};

#endif
```

**实现**

参考官方的example

注意，这里的isloaded并没有使用到，可以放入getconfig里面

```c
#include "iniconfig.h"
#include <iniparser/iniparser.h>

Iniconfig* Iniconfig::config = nullptr;

Iniconfig::Iniconfig() : _isloaded(false) {}

Iniconfig::~Iniconfig()
{

}

bool Iniconfig::loadfile(const std::string& path)
{
    dictionary*   ini = NULL;

    ini = iniparser_load(path.c_str());
    if (ini==NULL)
    {
        //LOG_ERROR("cannot parse file: %s\n", path.c_str());
        fprintf(stderr, "cannot parse file: %s\n", path.c_str());
        return false;
    }

    const char* ip    = iniparser_getstring(ini, "database:ip", "127.0.0.1");
    int   port  = iniparser_getint(ini, "database:port", 3306);
    const char* user  = iniparser_getstring(ini, "database:user", "root");
    const char* pwd   = iniparser_getstring(ini, "database:pwd", "123456");
    const char* db    = iniparser_getstring(ini, "database:db", "dongnaobike");
    int   sport = iniparser_getint(ini, "server:port", 9090);

    _config = st_env_config(std::string(ip), port, std::string(user), \
        std::string(pwd), std::string(db), sport);

    iniparser_freedict(ini);

    _isloaded = true;

    return true;
}

const st_env_config& Iniconfig::getconfig()
{
    return _config;
}

Iniconfig* Iniconfig::getInstance()
{
    if (config == nullptr)
    {
        config = new Iniconfig();
    }
    return config;
}
```

**全局文件定义**

1. 按照配置文件，将各个属性准备好
2. 实现拷贝构造和默认构造
3. 重载`=`号

```c
#ifndef SHBK_COMMON_INICONFIG_H_
#define SHBK_COMMON_INICONFIG_H_

#include <string>
typedef struct st_env_config
{
   //数据库的配置
   std::string db_ip;
   unsigned short db_port;
   std::string db_user;
   std::string db_pwd;
   std::string db_name;

   //服务的配置
   unsigned short svr_port;

   st_env_config()
   {
   };

   st_env_config(const std::string& db_ip, unsigned int db_port, const std::string& db_user, \
                 const std::string& db_pwd, const std::string& db_name, unsigned short svr_port)
   {
       this->db_ip    = db_ip;
       this->db_port  = db_port;
       this->db_user  = db_user;
       this->db_pwd   = db_pwd;
       this->db_name  = db_name;
       this->svr_port = svr_port;
   };

   st_env_config& operator =(const st_env_config& config)
   {
       if (this != &config)
       {
		   this->db_ip    = config.db_ip;
		   this->db_port  = config.db_port;
		   this->db_user  = config.db_user;
		   this->db_pwd	  = config.db_pwd;
		   this->db_name  = config.db_name;
		   this->svr_port = config.svr_port;

        }
        return *this;
    }
}_st_env_config;
#endif
```




# Log4cpp

### 安装

可以直接从U盘或者官网下载文件，地址：http://log4cpp.sourceforge.net/, 注意必须将安装包放在根目录下才会安装到系统的链接库中

依次执行如下命令

```shell
#解压,最后一个路径为压缩包
tar xzvf log4cpp-1.1.3.tar.gz
#make
cd lo4cpp-1.1.3
./configure --prefix="安装目录的绝对路径"
make
make install
```

### 包含的头文件

```c
#include <log4cpp/Category.hh>
#include <log4cpp/FileAppender.hh>
#include <log4cpp/PatternLayout.hh>
#include <log4cpp/OstreamAppender.hh>
```
输出日志到目的地(appenders)
```c++
// 输出到std::cout
log4cpp::Appender *appender = new log4cpp::OstreamAppender("root", &std::cout);
// 输出到log文件
log4cpp::Appender *appender = new log4cpp::FileAppender("root", "test.log");
```

> **appender**有以下这些：
>  log4cpp::FileAppender // 输出到文件
>  log4cpp::RollingFileAppender // 输出到回卷文件，即当文件到达某个大小后回卷
>  log4cpp::OstreamAppender // 输出到一个ostream类
>  log4cpp::RemoteSyslogAppender // 输出到远程syslog服务器
>  log4cpp::StringQueueAppender // 内存队列
>  log4cpp::SyslogAppender // 本地syslog
>  log4cpp::Win32DebugAppender // 发送到缺省系统调试器
>  log4cpp::NTEventLogAppender // 发送到win 事件日志

### 设置日期输出的格式

```c++
log4cpp::PatternLayout *patternLayout = new log4cpp::PatternLayout();
patternLayout->setConversionPattern("%d [%p] - %m%n");
appender->setLayout(patternLayout);
```

日志输出格式控制有：
 %% - 单个%号转义
 %c - 目录
 %d - the date\n Date format: The date format character may be followed by a date format specifier enclosed between braces. For example, %d{%\H:%M:%S,%l} or %d{%\d %m %Y %H:%\M:%S,%l}. If no date format specifier is given then the following format is used: "Wed Jan 02 02:03:55 1980". The date format specifier admits the same syntax as the ANSI C function strftime, with 1 addition. The addition is the specifier %l for milliseconds, padded with zeros to make 3 digits.
 %m - 信息
 %n - 平台特定的行分隔符
 %p - 优先级
 %r - milliseconds since this layout was created.
 %R - seconds since Jan 1, 1970
 %u - clock ticks since process start
 %x - the NDC
 %t - 线程名

默认情况下，输出格式的保存模式被设置为"%m%n"。

### 设置类别输出的的目录和日志优先级

```c++
log4cpp::Category &root =log4cpp::Category::getRoot();
root.setPriority(log4cpp::Priority::NOTICE);
root.addAppender(appender);
```

日志的级别总共有：NOTSET < DEBUG < INFO < NOTICE < WARN < ERROR < CRIT < ALERT < FATAL = EMERG。日志级别的意思是低于该级别的日志不会被记录。

### 定义一个宏

```c
#define LOG(__level) log4cpp::Category::getRoot() << log4cpp::Priority::__level << __FILE__ << " " << __LINE__ << ": "
```

当然也可以使用Category定义的函数：

```c++
	/**
    	* Log a message with the specified priority.
    	* @param priority The priority of this log message.
    	* @param stringFormat Format specifier for the string to write
    	* in the log file.
    	* @param ... The arguments for stringFormat
	**/
virtual void log(Priority::Value priority, const char* stringFormat,...) throw();
    /**
    * Log a message with the specified priority.
    * @param priority 这个日志消息的优先级
    * @param message 写到日志文件的字符串
    **/
virtual void log(Priority::Value priority,const std::string& message) throw();
void debug(const char* stringFormat, ...) throw();
void debug(const std::string& message) throw();
void info(const char* stringFormat, ...) throw();
```

### 使用宏定义记录日志

```c
LOG(DEBUG) << "i am happy.";
LOG(INFO)  << "oh, you happy, we happy.";
LOG(NOTICE)<< "please do not contact me. ";
LOG(WARN)  << "i am very busy now.";
LOG(ERROR) << "oh, what happed?";
```

在实际工程上应用，我们是使用日志配置文件去控制日志记录的。接下来让我们先配置一个日志配置文件：

```python
#定义Root category的属性
log4cpp.rootCategory=DEBUG, RootLog;
#定义RootLog属性
log4cpp.appender.RootLog=RollingFileAppender
log4cpp.appender.RootLog.layout=PatternLayout
#log4cpp.appender.RootLog.layout.ConversionPattern=%d{% m-%d %H:%M:%S %l} [%t][%p]%m%n
log4cpp.appender.RootLog.layout.ConversionPattern=%d{\%\m-%d %H:%M:%S %l} [%t][%p]%m%n
log4cpp.appender.RootLog.fileName=/var/log/qiniu_bike.log
log4cpp.appender.RootLog.maxFileSize=268435456 #256MB
log4cpp.appender.RootLog.fileNamePattern=qiniu_bike_%i.log
log4cpp.appender.RootLog.maxBackupIndex=256
```
然后使用如下函数去运用配置文件

```c
BOOL Logger::init(const std::string & log_conf_file)
{  
    try  
    {    
        log4cpp::PropertyConfigurator::configure(log_conf_file);
    }  catch(log4cpp::ConfigureFailure& f)  {    
        std::cerr << " load log config file " << log_conf_file.c_str() << " failed with result : " << f.what()<< std::endl;
     	return FALSE;
    } 
    m_Category = &log4cpp::Category::getRoot();
    return TRUE;
}
```



---
title: 进程
categories: 编程
tags:
  - linux
date: 2022-04-28 19:42:50
---

# 进程

### 进程概念

子进程和父进程在单独的内存中运行空间。在使用fork（）时，两个内存空间都有同样的内容。

内存写入、文件映射（mmap），以及由其中一个进程执行的解映射（munmap）不会影响对方。
**子进程与父进程完全相同除了以下几点**：

- 子进程有自己唯一的进程ID，而这个PID与任何现有流程组的ID不匹配，子进程的父进程ID与父进程的相同进程ID。
- 子对象不会继承其父对象的内存锁（mlock（2），mlockall（2））。
- 进程资源利用率（getrusage（2））和CPU时间子系统中的计数器（次数（2））重置为零。
- 子进程的待处理信号集最初是空的
- 子进程不继承与进程关联的父进程的记录锁
- 子项不会从其父项继承计时器设置定时器、报警、定时器。
- 子级不继承未完成的异步I/O来自其父级的操作，它也不会从其应用程序继承任何异步I/O。

### 创建、等待和销毁进程

使用fork函数，创建出一个子进程，有两个返回值，对于子进程为0， 父进程会大于0， 小于0说明fork失败

使用exit函数来终止正在执行的进程

使用wait系统调用暂停进程调用的执行直到它的一个子线程终止。

```C
#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <stdlib.h>

int main()
{
    int count = 0;
    int status = 0;

    pid_t fpid = fork(); //创建一个进程
    if (fpid < 0)
    {
        printf("error in fork");
    }
    else if (fpid == 0)
    {
        printf("children process, id is %d\n", getpid());
        count += 2;
        exit(2);//子进程已经退出
    }
    else
    {
        printf("parent process, id is %d\n", getpid());
        //getpid获取当前进程编号
        count++;
    }

    printf("统计结果为%d, 地址为%p\n", count, &count);
    //父进程捕捉子进程的状态
    wait(&status);//将状态信息保存在status中，并且一直阻塞到进程结束
    printf("parent: status : %d\n", WEXITSTATUS(status));
    //打印为无符号整数，如果是负数可能会溢出
    return 0;
}
```

### 孤儿进程

一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程所收养，并由init进程对它们完成状态收集工作。

### 僵尸进程

一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。

一个进程在调用exit命令结束自己的生命的时候，其实它并没有真正的被销毁，而是留下一个称为僵尸进程（Zombie）的数据结构（系统调用 exit，它的作用是使进程退出，但也仅仅限于将一个正常的进程变成一个僵尸进程，并不能将其完全销毁）。

在linux中使用ps可以看到标记为\<defunct\>的进程就是僵尸进程，它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程列表中保留一个位置，记载该进程的退出状态等信息供其他进程收集，除此之外，僵尸进程不再占有任何内存空间。

父进程结束后init进程会将这个进程结束掉。

### 守护进程*

也称为后台的进程，不与任何终端关联的进程，通常情况下守护进程在系统启动时就在运行，它们以root用户或者其他特殊用户(apache和postfix)运行，并能处理一些系统级的任务。守护进程脱离于终端，是为了避免进程在执行过程中的信息在任何终端上显示，并且进程也不会被任何终端所产生的终端信息所打断（比如关闭终端等）。

1. 调用fork(),创建新进程,它会是将来的守护进程
2. 在父进程中调用exit,保证子进程不是进程组长 

3. 调用setsid()创建新的会话区

4. 将当前目录改成根目录(如果把当前目录作为守护进程的目录,当前目录不能被卸载他作为守护进程的工作目录) 

5. 将标准输入,标准输出,标准错误重定向到/dev/null.

# 进程通信

### 信号

#### 产生

1. 由shell终端根据当前发生的错误（段错误、非法指令等）Ctrl+c而产生相应的信号
2. 在shell终端，使用kill或killall命令产生信号
3. 在程序代码中，调用kill系统调用产生信号，相当于system("kill -HUP 13733");

#### 分类

带*号的说明该信号不可捕捉

| 信号名称 | 说明                           |
| -------- | ------------------------------ |
| SIGABORT | 进程异常终止(coredump)         |
| SIGALRM  | 超时告警                       |
| SIGFPE   | 浮点运算异常                   |
| SIGHUP   | 连接挂断                       |
| SIGILL   | 非法指令                       |
| SIGINT   | 终端中断 (Ctrl+C将产生该信号)  |
| SIGKILL  | *终止进程                      |
| SIGPIPE  | 向没有读进程的管道写数据       |
| SIGQUIT  | 终端退出（Ctrl+\将产生该信号） |
| SIGSEGV  | 无效内存段访问(coredump)       |
| SIGTERM  | 终止                           |
| SIGCHLD  | 子进程已停止或退出             |
| SIGCONT  | *让暂停的进程继续执行          |
| SIGSTOP  | *停止执行(即“暂停")            |
| SIGTSTP  | 中断挂起                       |
| SIGTTIN  | 后台进程尝试读操作             |
| SIGTTOU  | 后台进程尝试写                 |

####    处理

忽略此信号

捕捉信号，指定信号处理函数处理

执行默认操作，终止进程

#### 信号捕捉函数

注意，函数是全程运行的，不会因为语句结束而结束。

1. **signal**

   ```c
   sighandler_t signal(int signum, sighandler_t handler);
   ```

   返回值和第二个参数为信号捕捉函数，一般为void类型和一个int参数。

   参数二有默认特殊值

   SIG_IGN 忽略信号

   SIG_DFL 恢复默认行为

2. **sigaction**

   首先需要了解结构体sigaction，然后调用设置信号集的函数。
   
   ```c
   struct sigaction {
               void (*sa_handler)(int);   /* 信号的响应函数 */
               sigset_t   sa_mask;          /* 屏蔽信号集 */                         
               int sa_flags;                /* 当sa_flags中包含 SA_RESETHAND时，接受到该信号并调用指定的信号处理函数执行之后，把该信号的响应行为重置为默认行为SIG_DFL */
   }
   int sigemptyset(sigset_t *set);
   /*
   初始化信号集为空，第二个参数为信号集
   */
   ```
   
   调用sigaction函数来捕捉信号
   
   
   ```c
   int sigaction(int signum, const struct sigaction *act,
                        struct sigaction *oldact);
   ```
   > 参数1:
   > 	信号，上面的分类
   > 参数2：
   > 	上面的结构体
   > 参数3：
   > 	置为0，或者设置为SA_RESETHAND



#### 信号发送

###### 一、单个信号发送

1. **kill**

   ```c
   int kill(pid_t pid, int sig);
   ```
   > pid:进程的id
   > sig:信号
   > 返回值:
   > 	失败返回-1
   
   
   kill函数，给指定的进程发送信号，发送过程中需要权限。
   
2. **alarm**

   ```c
   #include <unistd.h>
   unsigned int alarm(unsigned int seconds);
   ```

   发送一个SIGALRM信号，成功返回上次闹钟的剩余时间，失败返回-1。

3. **raise**

   ```c
   int  raise (int sig)
   ```
   
   给本进程自身发送信号

###### 二、多个信号发送

​    某进程正在执行某个信号对应的操作函数期间（该信号的安装函数），如果此时，该进程又多次收到同一个信号（同一种信号值的信号），如果该信号是不可靠信号（<32），则只能再响应一次。如果该信号是可靠信号（>32），则能再响应多次（不会遗漏）。但是，都是都必须等该次响应函数执行完之后，才能响应下一次。

​	某进程正在执行某个信号对应的操作函数期间（该信号的安装函数），如果此时，该进程收到另一个信号（不同信号值的信号），如果该信号被包含在当前信号的signaction的sa_mask（信号屏蔽集）中，则不会立即处理该信号。直到当前的信号处理函数执行完之后，才去执行该信号的处理函数。则立即中断当前执行过程（如果处于睡眠，比如sleep, 则立即被唤醒）而去执行这个新的信号响应。新的响应执行完之后，再在返回至原来的信号处理函数继续执行。

###### 信号集

信号集，用`sigset_t`类型表示，实质是一个无符号长整形。用来表示包含多个信号的集合。

###### 基本操作

| 函数        | 作用                                                         |
| ----------- | ------------------------------------------------------------ |
| sigemptyset | 把信号集清空                                                 |
| sigfillset  | 把所有已定义的信号填充到指定信号集                           |
| sigdelset   | 从指定的信号集中删除指定的信号                               |
| sigaddset   | 从指定的信号集中添加指定的信号                               |
| sigismember | 判断指定的信号是否在指定的信号集中，存在返回1，不是返回0，无效返回-1 |

###### 信号屏蔽字

进程的“信号屏蔽字”是一个信号集，想目标进程发送某信号时，如果这个信号在目标进程的信号屏蔽字中，则目标进程将不会捕获到该信号，即不会执行该信号的处理函数。当该进程的信号屏蔽字不再包含该信号时，则会捕获这个早已收到的信号（执行对应的函数）。

使用sigprocmask来修改进程的“信号屏蔽字”

```C
int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
```

> 参数:
> how:
> 	SIG_BLOCK   把参数set中的信号添加到信号屏蔽字中
> 	SIG_UNBLOCK 把参数set中的信号从信号屏蔽字中删除
> 	SIG_SETMASK 把参数set中的信号设置为信号屏蔽字
> oldset
> 	返回原来的信号屏蔽字


###### 获取未处理的信号

 当进程的信号屏蔽字中信号发生时，这些信号不会被该进程响应，可通过sigpending函数获取这些已经发生了但是没有被处理的信号。

```C
#include <signal.h>
int sigpending(sigset_t *set);
```
> 参数： 信号集
> 返回值： 成功则返回0
> 		失败则返回-1

###### 阻塞式等待信号

1. pause

   阻塞进程，直到发生任一信号后

2. sigsuspend

   用指定的参数设置信号屏蔽字，然后阻塞时等待信号的发生。即，只等待信号屏蔽字之外的信号

### 管道

IPC(进程间通信) 有多种方式, 管道是IPC的最基本的方式.

管道是“半双工”的，即是单向的。管道是FIFO（先进先出）的。

单进程中的管道：

  int fd[2]

使用文件描述符fd[1], 向管道写数据

使用文件描述符fd[0], 从管道读数据

##### 创建

```C
#include <unistd.h>
int pipe(int pipefd[2]);
/*
成功时，返回零。出现错误时，返回-1，设置errno，并且pipefd保持不变。
*/
```

注意：获取两个“文件描述符”，分别对应管道的读端和写端。

fd[0]: 是管道的**读**端

fd[1]: 是管道的**写**端

​    如果对fd[0]进行写操作，对fd[1]进行读操作，可能导致不可预期的错误。

##### 多进程

 注意：创建管道之后，再创建子进程，此时一共有4个文件描述符。

​       4个端口，父子进程分别有一个读端口和一个写端口

​            向任意一个写端口写数据，即可从任意一个读端口获取数据。

##### 使用管道启动新程序

​    有程序P1, P2

​         使用管道进行通信

​         P1由用户输入一个字符串，然后把该字符串发给p2

​         P2接收到以后，把该字符串打印出来

 

P1:

​    创建管道

​    创建子进程

​    在子进程中用exec替换成p2，

​    （在使用exec 时，把管道的读端作为exec的参数）

​    在父进程中，获取用户的输入，然后把所输入的字符串发送给p2

​    (即，父进程把字符串写入管道)

 

P2:

​     从参数中获取管道的读端（参数即为p2的main函数的参数）

​     读管道

​     把读到的字符串打印出来

​         

 

难点：子进程使用exec启动新程序运行后，

新进程能够使用原来子进程的管道（因为exec能共享原来的文件描述符）

但问题是新进程并不知道原来的文件描述符是多少！

 

解决方案：

   把子进程中的管道文件描述符，用exec的参数传递给新进程。

##### 关闭管道

问题：

对管道进行read时，如果管道中已经没有数据了，此时读操作将被“阻塞”。

如果此时管道的写端已经被close了，则写操作将可能被一直阻塞！

而此时的阻塞已经没有任何意义了。（因为管道的写端已经被关闭，即不会再写入数据了）

 

解决方案：

如果不准备再向管道写入数据，则把该管道的所有写端都关闭，

则，此时再对该管道read时，就会返回0，而不再阻塞该读操作。（管道的特性）

注意，这是管道的特性。

   如果有多个写端口，而只关闭了一个写端，那么无数据时读操作仍将被阻塞。

 

实际实现方式：

父子进程各有一个管道的读端和写端；

把父进程的读端（或写端）关闭；

把子进程的写端（或读端）关闭；

使这个“4端口”管道变成单向的“2端口”管道，如图：

1)   把父进程的写操作注释掉，此时子进程的读操作将被一直阻塞

2)   把父进程的写操作注释掉，并close父进程的写端

此时子进程的读操作将将被阻塞。

3)   把父进程的写操作注释掉，并把父子进程的写端都close

此时子进程读操作将直接返回0，而不再阻塞。

4)   最终实现方案：

关闭父进程的读端，关闭子进程的写端。

当父进程不再发送数据时，就关闭本进程的写端。

练习：创建一个子进程

​     父进程通过管道向子进程发送数据（字符串）

​    该字符串由用户输入。

​    当用户输入”exit”时, 就不再向子进程发送数据，并关闭该端的管道。

 

​    子进程从管道读取数据，并输出。

​    直到父进程关闭了管道的写端。

 

 

练习：

创建一个子进程

父进程：

循环等待用户输入，

用户每输入一个单词后，就把该单词用管道发送给子进程，

直到用户输入exit。

子进程：

   每收到一个单词后，就打印输出

   直到用户在父进程中结束输入。

##### 管道作为标准输入和输出

把管道作为标准输入和标准输出的优点：

1. 子进程使用exec启动新程序时，就不需要再把管道的文件描述符传递给新程序了。

2. 可以直接使用使用标准输入（或标准输出）的程序。

比如 od –c （统计字符个数，结果为八进制）

 

实现原理：

1. 使用dup复制文件描述符

2. 用exec启动新程序后，原进程中已打开的文件描述符仍保持打开，

即可以共享原进程中的文件描述符。

注意：dup的用法

```c
#include <unistd.h>
int dup(int oldfd);
/*
dup复制文件描述符，返回的新文件描述符和被复制的文件描述符，指向同一个文件或管道。
*/
```

##### popen/pclose

读取外部程序的输出

popen的作用：

用来在两个程序之间传递数据:

在程序A中使用popen调用程序B时，有两种用法：

程序A读取程序B的输出（使用fread读取）

程序A发送数据给程序B，以作为程序B的标准输入。（使用fwrite写入）

```c
#include <stdio.h>
FILE *popen(const char *command, const char *type);
int pclose(FILE *stream);
/*
参数：
	终端命令，读取类型(同fopen)
返回值：成功，返回FILE*
	失败， 返回空。
*/
```

把输出写到外部程序

popen的原理：

先使用fork创建一个子进程，

然后在子进程中使用exec执行指定外部程序，并返回一个文件指针FILE*给父进程。

当使用”r”时，该FILE指向外部程序的标准输出

当使用”w”时，该FILE指向外部程序的标准输入。

popen的优缺点：

优点：可以使用shell扩展（比如命令中可以使用通配符），使用方便。

缺点：每调用一次popen, 将要启动两个进程(shell和被指定的程序)， 资源消耗大。

如果所有管道写端对应的文件描述符被关闭，则read返回0

如果所有管道读端对应的文件描述符被关闭，则write操作会产生信号SIGPIPE

### 消息队列

#### 定义

消息队列，用于从一个进程向另一个进程发送数据。但仅把数据发送到一个“队列”中，而不指定由哪个进程来接受。消息队列，独立与发送消息的进程和接收消息的进程。

  （信号、管道、命名管道都不独立与发送和接收进程）

消息队列，有最大长度限制：MSGMNB；消息队列中的单条消息，也有最大长度限制：MSGMAX

#### 获取

```c
int msgget(key_t key, int msgflg);
/*
功能：
	获取或创建一个消息队列
参数：
	与共享内存相似。
  	msgflag可使用IPC_CREAT
返回值：
	成功，返回正整数，即“消息队列标识符”。
	失败，返回-1
*/
```
#### 发送
```c
int msgsnd(int msqid,  const void *msgp,  size_t msgsz,  int msgflg);
/*
功能：
	发送一个消息，即把消息添加到消息队列中。
参数：
	msgid 消息队列标识符
	msgp  消息指针	
	msgsz：消息的长度（不包含第一个成员msg_type）
	msgflg：如果包含： IPC_NOWAIT, 则消息队列满时，不发送该消息，而立即返回-1
	如果不包含：IPC_NOWAIT,则消息队列满时，挂起本进程，直到消息队列有空间可用。
返回值：
	成功，返回0
	失败，返回-1   
注：消息的类型需要自己定义。但要求其第一个结构成员为long int
*/
struct my_msg_st {
     long int msg_type;  /* 消息的类型，取>0, 接收消息时可使用该值 */
    Data data;/*other info */ 
} 
```
#### 接收
```c
ssize_t msgrcv (int msqid, void *msgp,  size_t msgsz,  long msgtype,  int msgflg);
```
> 功能：
> 	从消息队列中接收一条消息。
> 参数：
> 	msgid 消息队列标识符
> 	msgp  用于接收消息的缓存
> 	msgsz  要接收的消息的长度（不包括其第一个成员）
> 	msgtype 指定接收消息的类型
> 		0： 从消息队列中获取第一个消息，以实现顺序接受（先发先收）
> 		>0: 从消队列中获取相同类型的第一个消息
> 		<0: 从消息队列中获取消息类型		<=（msgtyep的绝对值）的第一个消息
> 	msgflg: 如果包含  IPC_NOWAIT, 则当消息队列中没有指定类型的消息时，立即返回-1，如果不包含：IPC_NOWAIT,则当消息队列中没有指定类型的消息时，挂起本进程，直到收到指定类型的消息。
> 返回值：
> 	成功，返回接收到的消息的长度（不包含第一个成员msg_type)
> 	失败，返回-1

#### 控制

```c
int msgctl(int msqid, int cmd, struct msqid_ds *buf);
/*
功能：
	与shmctl类似
参数：
	cmd 常用命令：
	IPC_RMID  删除消息队列
返回值：
	成功, 返回 0
	失败，返回-1
*/
```
### 信号量

#### 定义

 信号量，是一种特殊的变量。

  只能对信号量执行P操作和V操作

  P操作， 如果信号量的值 > 0,  则把该信号量减1

​        如果信号量的值 ==0, 则挂起该进程。    

  V操作: 如果有进程因该信号量而被挂起，则恢复该进程运行

​        如果没有进程因该信号量而挂起，则把该信号量加1

  注意：P操作、V操作都是原子操作，即其在执行时，不会被中断。

注意：此指的“信号量”是指System V IPC的信号量，与线程所使用的信号量不同。该信号量，用于**进程间通信**。

#### 使用

##### 获取
```c
int semget(key_t key, int nsems,  int semflg);
```
> 功能：
> 	获取一个已存在的、或创建一个新的信号量量，返回该信号量的标识符
> 参数：
> 	key, 键值，该键值对应一个唯一的信号量。类似于共享内存的键值。
> 不同的进程可通过该键值和semget获取唯一的信号量。特殊键值：IPC_PRIVAT该信号量只允许创建者本身， 可用于父子进程间通信。
> nsems：
> 	需要的信号量数目，一般取1
> sem_flags：
> 	与共享内存的sem_flags类似。IPC_CREAT, 如果该信号量未存在，则创建该信号量如果该信号量已存在，也不发送错误。
> 返回值： 
> 	成功，则返回一个正数
> 	失败,  返回返回-1

##### 操作
```c
int semop(int semid,  struct sembuf *sops,  unsigned nsops);
```

> 功能：
	改变信号量的值，即对信号量执行P操作、或V操作。
参数：
	semid, 信号量标识符， 即semget的返回值
	sops, 是一个数组，元素类型为struct sembuf
	nsops:
		表示第二个参数sops所表示的数组的大小，即表示有几个struct sembuf 
返回值： 
	失败， 返回-1
	成功， 返回 0
```c
struct sembuf {
    short sem_num; //信号量组中的编号（即指定对哪个信号量操作）
            //semget实际是获取一组信号量
            //如果只获取了一个信号量，则该成员取0
    short sem_op;   //  -1, 表示P操作
             //  1, 表示V操作
    short sem_flg;   // SEM_UNDO : 如果进程在终止时，没有释放信号量，如果不设置指定标志，应该设置为0，则，自动释放该信号量。
}
```
##### 控制
```c
int semctl(int semid, int sem_num, int cmd, ...);
/*
功能：
	对信号量进行控制
参数：
	semid, 信号量标识符
	sem_num, 信号量组中的编号，如果只有一个信号量，则取0
	cmd， SETVAL  把信号量初始化为指定的值，具体的值由第4个参数确定
注意：
	只能对信号量初始化一次，如果在各进程中，分别对该信号量进行初始化，则可能导致错误！
	IPC_RMID 删除信号量
参数4, 类型为：union semun {
	int   val;   // SETVAL命令要设置的值
	struct semid_ds *buf;
	unsigned short  *array;
}

注意：union semun类型要求自己定义有些Linux发行版在sys/sem.h中定义，有些发行版则没有定义。
可自定义如下：
------------------------------------------------------------
#if
	defined(__GNU_LIBRARY__)&&!defined(_SEM_SEMUN_UNDEFINED)
#else
    union semun {
        int val;               
        struct semid_ds *buf;  
        unsigned short int *array; 
        struct seminfo *__buf; 
    };
#endif 
------------------------------------------------------------
*/
```
​	

# 进程共享内存

### shmm

##### 准备

```c
key_t ftok(const char *pathname,int proj_id)
```

##### 创建一个共享内存块

```C
int shmget(key_t key,size_t size,int shmflg)
/*
参数说明：
	size   － 申请的共享内存的大小，为4k的整数倍；
	shmflg － IPC_CREAT 创建新的共享内存,已存在 使用IPC_EXCL
*/
```

##### 挂接共享内存

```c
void *shmat(int shmid,const void *shmaddr, int shmflg)
/*
参数说明：
	shmid   － 挂接的共享内存ID.
	shmaddr － 一般为0，表示连接到由内核选择的第一个可用地址上
	shmflg  － 一般为0
*/
```

##### 取消映射

```c
int shmdt(const void *shmaddr);
```



##### 控制共享内存

```c
int shmctl(int shmid, int cmd, struct shmid_ds  *buf);
/*
参数:
	shmid － 由shmget返回的共享内存标识码
	cmd   － 将要采取的动作（可取值:IPC_STAT、IPC_SET、IPC_RMID）
	buf   － 指向一个保存着共享内存的模式状态和访问权限的数据结构
*/
```



### mmap

见淘宝文件系统

```c
#include <sys/mman.h>
void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);
int munmap(void *addr, size_t length);　
```
> 参数addr：指向欲映射的内存起始地址，通常设为 NULL，代表让系统自动选
            定地址，映射成功后返回该地址。

     参数length：代表将文件中多大的部分映射到内存。
     
     参数prot：映射区域的保护方式。可以为以下几种方式的组合：
    
           PROT_EXEC         执行   
           PROT_READ         读取
           PROT_WRITE        写入
          PROT_NONE         不能存取

> 参数flags：影响映射区域的各种特性。
>
> 参数fd：要映射到内存中的文件描述符。如果使用匿名内存映射时，即flags中设置了MAP_ANONYMOUS，fd设为-1。有些系统不支持匿名内存映射，则可以使用fopen打开/dev/zero文件，然后对该文件进行映射，可以同样达到匿名内存映射的效果。
>
> 参数offset：文件映射的偏移量，通常设置为0，代表从文件最前方开始对应，offset必须是分页大小的整数倍。



下面是flag参数的表格

| 参数          | 作用                                                         |
| ------------- | ------------------------------------------------------------ |
| MAP_SHARED    | 映射区域数据与文件对应，允许其他进程共享                     |
| MAP_PRIVATE   | 映射区域生成文件的copy，修改不同步文件                       |
| MAP_ANONYMOUS | 建立匿名映射。此时会忽略参数fd，不涉及文件，而且映射区域无法和其他进程共享。 |
| MAP_DENYWRITE | 允许对映射区域的写入操作，其他对文件直接写入的操作将会被拒绝。 |
| MAP_LOCKED    | 将映射区域锁定住，这表示该区域不会被置swap                   |


# 线程

### 线程的创建

```C
#include <pthread.h>
int  pthread_create (pthread_t *thread,pthread_attr_t *attr,
void *(*start_routine)(void*), void *arg);
/*
参数：
	thread, 指向新线程的标识符。通过该指针返回所创建线程的标识符。
	attr, 用来设置新线程的属性。一般取默认属性，即该参数取NULL
	start_routine, 该线程的处理函数指针,该函数的返回类型和参数类型都是void*，该函数运行结束，则线程结束。
	arg, 线程处理函数start_routine的参数           
功能：
	创建一个新线程，同时指定该线程的属性、执行函数、执行函数的参数,通过参数1返回该线程的标识符。       
返回值：
	成功，返回0
	失败，返回错误代码             
注意：大部分pthread_开头的函数成功时返回0，失败时返回错误码（而不是-1）
*/
```

注意：使用fork创建进程后，进程不会马上就启动，但是是和父进程同时执行fork后的代码。使用pthread_create创建线程后，新线程马上就启动，即执行对应的线程处理函数。

注意，线程的运行是独立的，程序运行不会在执行线程函数完之后再继续执行下面的代码，如果在线程函数的外部释放线程内部的变量，会引发错误

### 线程的终止

```c
void  pthread_exit (void *retval)
/*
功能：在线程函数内部调用该函数。终止该线程，并通过参数retval返回一个指针。该指针不能指向该线程的局部变量。
*/
```

### 等待指定线程结束

```c
int  pthread_join  (pthread_t   th,void ** thread_return);
/*
参数：
	th,  指定等待的线程
	thread_return, 指向该线程函数的返回值,线程函数的返回值类型为void*，故该参数的类型为void**
功能：
	类似与进程中的waitpid,等待指定的线程结束，并使参数指向该线程函数的返回值（用pthread_exit返回的值）
*/
```

使用线程程序的编译

 (1) 编译时，定义宏_REENTRANT

即： gcc -D_REENTRANT （#define REENTRANT)

功能：告诉编译器，编译时需要可重入功能。即使得，在编译时，编译部分函数的可重入版本。

**注**：在单线程程序中，整个程序都是顺序执行的，一个函数在同一时刻只能被一个函数调用，但在多线程中，由于并发性，一个函数可能同时被多个函数调用，此时这个函数就成了临界资源，很容易造成调用函数处理结果的相互影响，如果一个函数在多线程并发的环境中每次被调用产生的结果是不确定的，我们就说这个函数是"不可重入的"/"线程不安全"的。       

 (2) 编译时，指定线程库

即: gcc -lpthread

功能：使用系统默认的NPTL线程库，即在默认路径中寻找库文件libpthread.so ，默认路径为/usr/lib和/usr/local/lib     

总结：一般使用如下形式即可

gcc  -D_REENTRANT  -lpthread  mythread.c  -o  mythread 

### 线程同步

1）**线程的互斥** - 指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。

2）**线程的同步** - 指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。

1. 问题

     同一个进程内的各个线程，共享该进程内的全局变量

     如果多个线程同时对某个全局变量进行访问时，就可能导致竞态。

    解决办法： 对临界区使用信号量、或互斥量。

2. 信号量和互斥量的选择。

  对于同步和互斥，使用信号量或互斥量都可以实现。

  使用时，选择更符合语义的手段：

​        如果要求最多只允许一个线程进入临界区，则使用互斥量

​        如果要求多个线程之间的执行顺序满足某个约束，则使用信号量

   

### 信号量

#### 1）什么是信号量

​     此时所指的“信号量”是指用于同一个进程内多个线程之间的信号量。

​     即POSIX信号量，而不是System V信号量（用于进程之间的同步)

​    

​     用于线程的信号量的原理，与用于进程之间的信号量的原理相同。

​     都有P操作、V操作。

​     信号量的表示：sem_t 类型

####   2) 信号量的初始化

```c
int sem_init (sem_t *sem，  int pshared,  unsigned int value);
/*
参数：sem, 指向被初始化的信号量

pshared, 0：表示该信号量是该进程内使用的“局部信号量”， 不再被其它进程共享。
		非0：该信号量可被其他进程共享，Linux不支持这种信号量

value: 信号量的初值。>= 0

返回值：成功，返回0
	失败， 返回错误码
*/
```

####   3) 信号量的P操作

​     sem_wait

​     原型：int  sem_wait (sem_t *sem);

​     返回值：成功，返回0

​         失败， 返回错误码

  

####   4) 信号量的V操作

​     sem_post

​     原型：int sem_post (sem_t *sem);

​     返回值：成功，返回0

​          失败， 返回错误码

  

####   5) 信号量的删除

​    sem_destroy

​    原型：int sem_destroy (sem_t *sem);

​    返回值：成功，返回0

​          失败， 返回错误码

  

### 互斥量

####   1）什么是互斥量

​     效果上等同于初值为1的信号量

​     互斥量的使用：类型为 pthread_mutex_t

####   2）互斥量的初始化

​     pthread_mutex_init

​     原型：int pthread_mutex_init(pthread_mutex_t *mutex,

​                    pthread_mutexattr_t *attr);

​     参数：mutex， 指向被初始化的互斥量

​         attr, 指向互斥量的属性

​             一般取默认属性（当一个线程已获取互斥量后，该线程再次获取该信号量，将导致死锁!)

  

####   3) 互斥量的获取

​    pthread_mutex_lock

​    原型：int pthread_mutex_lock (pthread_mutex_t *mutex);  

  

####   4）互斥量的释放

​     pthread_mutex_unlock

​     原型：int pthread_mutex_unlock (pthread_mutex_t *mutex);     

​    

####   5）互斥量的删除

​     pthread_mutex_destroy

​     int pthread_mutex_destroy (pthread_mutex_t *mutex); 

### 条件变量

  与互斥锁不同，条件变量是用来等待而不是用来上锁的。条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用。

 条件变量使我们可以睡眠等待某种条件出现。条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待"条件变量的条件成立"而挂起；另一个线程使"条件成立"（给出条件成立信号）。

条件的检测是在互斥锁的保护下进行的。如果一个条件为假，一个线程自动阻塞，并释放等待状态改变的互斥锁。如果另一个线程改变了条件，它发信号给关联的条件变量，唤醒一个或多个等待它的线程，重新获得互斥锁，重新评价条件。如果两进程共享可读写的内存，条件变量可以被用来实现这两进程间的线程同步。

#### 条件变量初始化 

  pthread_cond_init

  原型：int pthread_cond_init (pthread_cond_t *cond, const pthread_condattr_t *attr);

参数：cond,  条件变量指针

   attr  条件变量高级属性

man 安装：  apt-get install manpages-posix-dev

 

#### 唤醒一个等待线程

  pthread_cond_signal 通知条件变量,唤醒一个等待者 

原型： int pthread_cond_signal (pthread_cond_t *cond);

参数：cond,  条件变量指针

   

##### 1.   唤醒所有等待该条件变量的线程

pthread_cond_broadcast 广播条件变量 

原型： int pthread_cond_broadcast (pthread_cond_t *cond);

参数：cond,  条件变量指针

 

##### 2.   等待条件变量超时被唤醒

pthread_cond_timedwait 等待条件变量cond被唤醒,直到由一个信号或广播，或绝对时间abstime到 * 才唤醒该线程

原型： int pthread_cond_timedwait (pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime);

参数：cond,  条件变量指针

   pthread_mutex_t *mutex 互斥量

   const struct timespec *abstime 等待被唤醒的绝对超时时间

 

##### 3.   等待条件变量被唤醒

pthread_cond_wait 等待条件变量cond被唤醒(由一个信号或者广播) 

原型： int pthread_cond_wait (pthread_cond_t *cond, pthread_mutex_t *mutex);

参数：cond,  条件变量指针

​			pthread_mutex_t *mutex 互斥量

常见错误码： [EINVAL] cond或mutex无效,

​						[EINVAL] 同时等待不同的互斥量  

​						[EINVAL] 主调线程没有占有互斥量 

#### 释放/销毁条件变量

pthread_cond_destroy 待销毁的条件变量 

原型： int pthread_cond_destroy (pthread_cond_t *cond);

参数：cond,  条件变量指针

 

 

 


# IO多路复用

本质上还是同步IO，一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入就绪状态，select()函数就可以返回。

# SELECT&POLL

为什么要用select和poll，而是不用线程：提高并发量。需要使用两个system call（select 和 recvfrom），而blocking IO只调用了一个system call（recvfrom）。但是，用select的优势在于它可以同时处理多个connection。

### select

#### 使用的函数

```c
#include <sys/select.h>

int select(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, struct timeval *timeout);
```

> nfds ：  最大的文件描述符加1。一般使用系统变量`FD_SETSIZE`，系统默认的最大文件描述符(一般为1024)。
>
> readfds： 用于检查可读的文件集合，是一个为fd_set的结构体
>
> writefds：用于检查可写性，可以使用`NULL`表示只读。
>
> exceptfds：用于检查异常的数据，同上
>
> timeout：一个指向timeval结构的指针，用于决定select等待I/o的最长时间。如果为空将一直等待。
>
> timeval结构的定义：
>
> ```c
> struct timeval{
> 	long tv_sec; // seconds
> 	long tv_usec; // microseconds
> }
> ```
>
> 返回值： >0 是已就绪的文件句柄的总数， =0 超时, <0 表示出错，错误: errno 
>

 

```c
#include <sys/select.h> 
int FD_ZERO(fd_set *fdset); //一个 fd_set类型变量的所有位都设为 0 
int FD_CLR(int fd, fd_set *fdset); //清除某个位时可以使用
int FD_SET(int fd, fd_set *fd_set); //设置变量的某个位置位
int FD_ISSET(int fd, fd_set *fdset); //测试某个位是否被置位
```

#### 流程

1. 把服务器端加入fd_set中

2. 使用select，如果返回值大于等于1进入下一步

3. 扫描所有的文件符号

   1. 找到文件符号

   2. 如果是服务器端，则开始accept，然后将客户端加入集合中

   3. 否则，获取数据量(iotcl, linux文件中的函数)

      int ioctl(int fd, int cmd, int* argc)，cmd取FIONREAD, 参数三存放读取的数据

      1. 处理客户端请求
      2. 关闭客户端句柄，并且从集合中清除掉该文件句柄

### poll

和select 一样，如果没有事件发生，则进入休眠状态，如果在规定时间内有事件发生，则返回成功，规定时间过后仍然没有事件发生则返回失败。可见，等待期间将进程休眠，利用事件驱动来唤醒进程，将更能提高CPU的效率。

poll 和select 区别： select 有文件句柄上线设置，值为FD_SETSIZE，而poll 理论上没有限制!

#### 使用的函数

```c
#include <poll.h>
int poll(struct pollfd *fds, nfds_t nfds, int timeout);
```

> 输入参数：
>
> ​       fds：//可以传递多个结构体，也就是说可以监测多个驱动设备所产生的事件，只要有一个产生了请求事件，就能立即返回
>
> ```c
> struct pollfd {
> 	int fd;         /*文件描述符  open打开的那个*/
> 	short events;   /*请求的事件类型，监视驱动文件的事件掩码*/ POLLIN | POLLOUT
> 	short revents;   /*驱动文件实际返回的事件*/
> }
> ```
>
> ​       nfds: //监测驱动文件的个数
>
> ​       timeout://超时时间，单位是ms
>
> 事件类型events 可以为下列值：	
>
> | 事件值     | 事件类型                           |
> | ---------- | ---------------------------------- |
> | POLLIN     | 可接收事件                         |
> | POLLRDNORM | 有普通数据可读，等效与POLLIN       |
> | POLLPRI    | 有紧迫数据可读                     |
> | POLLOUT    | 可处理事件                         |
> | POLLER     | 指定的文件描述符发生错误           |
> | POLLHUP    | 指定的文件描述符挂起事件           |
>| POLLNVAL   | 无效的请求，打不开指定的文件描述符 |
> 
>返回值：
> 
>​     有事件发生 返回revents域不为0的文件描述符个数
> 
>​     超时：return 0
> 
>​     失败：return -1  错误：errno

#### 流程

1. 设置fds数组和当前的最大文件句柄

2. 将fds数组的第服务器句柄个元素的数据设置

   fd: 服务器fd

   events: POLLIN

   revents: 0

   判断是否当前最大句柄是否小于服务器句柄，大于则将当前最大句柄+1赋值给当前最大句柄，提高效率

3. 遍历数组，从当前最大句柄结束，如果某个fds数据的revents不为0或者event不为POLLIN，则判断是否为服务器socket。

   1. 同select， 同服务器的设置一样把客户端句柄设置到fds数组中。
   2. 否则使用read来读取内容，
      1. 使用memset来清空数组。
      2. 存在数据，设置为POLLOUT。
   3. 为POLLOUT，处理事件，然后清空这个元素，或者设置为POLLIN

# epoll

### reactor设计模式

 1）响应快，不必为单个同步事件所阻塞，虽然Reactor本身依然是同步的；


 2）编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销；


 3）可扩展性，可以方便的通过增加Reactor实例个数来充分利用CPU资源； 

4）可复用性，reactor框架本身与具体事件处理逻辑无关，具有很高的复用性；

### 通用接口

#### 1.创建EPOLL 句柄

```c
int epoll_create(int size); 
```

#### 2.向EPOLL对象中添加、修改或者删除感兴趣的事件

```c
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); 
```

> op取值：
>
> EPOLL_CTL_ADD        添加新的事件到epoll中
>
> EPOLL_CTL_MOD       修改EPOLL中的事件 EPOLL_CTL_DEL          删除epoll中的事件
>
> events取值：
>
> EPOLLIN   表示有数据可以读出(接受连接、关闭连接)
>
> EPOLLOUT  表示连接可以写入数据发送（向服务器发起连接，连接成功事件）EPOLLERR  表示对应的连接发生错误EPOLLHUP  表示对应的连接被挂起EPOLLLET   表示对应的连接使用边缘触发

#### 3.收集在epoll监控的事件中已经发生的事件

```c
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout); 
```

> epfd： epoll的描述符。
>
> events：则是分配好的 epoll_event结构体数组，epoll将会把发生的事件复制到 events数组中（events不可以是空指针，内核只负责把数据复制到这个 events数组中，不会去帮助我们在用户态中分配内存。内核这种做法效率很高）。
>
>  maxevents： 本次可以返回的最大事件数目，通常 maxevents参数与预分配的events数组的大小是相等的。
>
> timeout： 表示在没有检测到事件发生时最多等待的时间（单位为毫秒），如果 timeout为0，立刻返回，不会等待。-1表示无限期阻塞

### 关键结构

```c
struct epoll_event{
	__uint32_t  events;
	epoll_data_t data;
}

typedef union epoll_data{
	void *ptr;
	int fd;
	uint32_t u32;
	uint64_t u64;//注意定义是union，取决于你将上下文设置为什么数据结构
}epoll_data_t
```



### 水平和边缘触发

Level_triggered(水平触发)：当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据一次性全部读写完(如读写缓冲区太小)，那么下次调用 epoll_wait()时，它还会通知你在上没读写完的文件描述符上继续读写，当然如果你一直不去读写，它会一直通知你！！！如果系统中有大量你不需要读写的就绪文件描述符，而它们每次都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率！！！
设置方式: 默认即水平触发(redis)

Edge_triggered(边缘触发)：当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用epoll_wait()时，它不会通知你，也就是它只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你！！！这种模式比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符！！！
设置方式: stat->_ev.events = EPOLLIN | EPOLLET(nginx)

### 关键问题的解决

#### 如何解决事件与 连接socket句柄挂钩，快速完成检索？

使用结构体，把socket和句柄绑定到connectstat结构体上面。然后将epoll_data_t设置为该结构体的指针。

#### 如何突破 系统默认状态最多允许 1024 个连接限制？

修改系统文件，就可以每次开机设置为10000连接设置

```shell
ulimit -a
vi /etc/rc.local #在文件中加入以下命令
ulimit -n 10000 #更改为10000

```

#### epoll 监听的事件没有超时处理机制，如何处理？

下面的核心框架

### 流程

大部分流程同http服务器

### 核心框架




# Nginx

### 高并发内存池

```c
typedef struct {
    u_char               *last;         // 保存当前数据块中内存分配指针的当前位置
    u_char               *end;         // 保存内存块的结束位置
    ngx_pool_t           *next;      // 内存池由多块内存块组成，指向下一个数据块的位置
    ngx_uint_t            failed;      // 当前数据块内存不足引起分配失败的次数
} ngx_pool_data_t;
 
struct ngx_pool_s {
    ngx_pool_data_t       d;        // 内存池当前的数据区指针的结构体
    size_t                max;      // 当前数据块最大可分配的内存大小（Bytes）
    ngx_pool_t           *current;  // 当前正在使用的数据块的指针
    ngx_pool_large_t     *large;    // pool 中指向大数据块的指针（大数据快是指 size > max 的数据块）
};

```

内存池的创建销毁和重置

| **操作**   | **函数**                                    |
| ---------- | ------------------------------------------- |
| 创建内存池 | ngx_pool_t  * ngx_create_pool(size_t size); |
| 销毁内存池 | void  ngx_destroy_pool(ngx_pool_t *pool);   |
| 重置内存池 | void  ngx_reset_pool(ngx_pool_t *pool);     |

内存池的申请释放和回收

| **操作**                 | **函数**                                             |
| ------------------------ | ---------------------------------------------------- |
| 内存申请（对齐）         | void  * ngx_palloc(ngx_pool_t *pool, size_t  size);  |
| 内存申请（不对齐）       | void  * ngx_pnalloc(ngx_pool_t *pool, size_t  size); |
| 内存申请（对齐并初始化） | void  * ngx_pcalloc(ngx_pool_t  *pool, size_t size); |
| 内存清除                 | ngx_int_t ngx_pfree(ngx_pool_t *pool, void *p);      |

### 线程池

**任务** － 待处理的工作，通常由标识、上下文和处理函数组成。

**任务队列** － 按顺序保存待处理的任务序列，等待线程中的线程组处理。

**线程池** －  由多个已启动的一组线程组成。 

**条件变量** － 一种同步机制，允许线程挂起，直到共享数据上的某些条件得到满足。

**互斥锁** － 保证在任一时刻，只能有一个线程访问该对象。


### [libevent](https://github.com/libevent/libevent/releases/download/release-2.1.12-stable/libevent-2.1.12-stable.tar.gz)安装

**注意**：以root用户身份操作

1. 下载源码包

2. 解压

3. 配置安装路径

4. 编译并安装

   ```shell
   tar zxvf libevent-2.1.12-stable.tar.gz
   cd libevent-2.1.12-stable
./configure --disable-openssl
   make
make install
   ```

5. 测试libevent是否安装成功：

   ```shell
    ls -la /usr/local/include | grep event
   ```

6. 如果编译后的程序提示找不到libevent的so，则创建库的链接和缓存文件
   ```shell
ldconfig
   ```
编译选项  -levent

### 使用

详见中文文档
### protobuf序列化

protobuf是一种比json和xml等序列化工具更加轻量和高效的结构化数据存储格式，性能比json和xml更强。

### 原理



